name: Build and Test KIND CRI-O Image

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main, develop ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Fast build test for PRs and feature branches
  build-test:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    permissions:
      contents: read
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v6

    - name: Get versions
      id: versions
      run: |
        # Get latest CRI-O version with error handling
        CRIO_RESPONSE=$(curl -s https://api.github.com/repos/cri-o/cri-o/releases/latest)
        if echo "$CRIO_RESPONSE" | jq -e '.tag_name' > /dev/null 2>&1; then
          CRIO_LATEST=$(echo "$CRIO_RESPONSE" | jq -r '.tag_name')
        else
          echo "Error getting CRI-O version: $CRIO_RESPONSE"
          CRIO_LATEST="v1.33.7"  # fallback version
        fi
        
        echo "crio_latest=$CRIO_LATEST" >> $GITHUB_OUTPUT
        echo "Latest CRI-O: $CRIO_LATEST"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build test image (single arch, no push)
      run: |
        echo "ðŸ§ª Testing build with CRI-O ${{ steps.versions.outputs.crio_latest }}"
        
        # Build only for amd64 to test quickly
        docker build \
          --build-arg CRIO_VERSION=${{ steps.versions.outputs.crio_latest }} \
          --build-arg KIND_VERSION=v1.31.0 \
          --tag test-image:latest \
          .
        
        echo "âœ… Build test successful!"

  # Full multi-version build and push for main/develop
  build-and-push:
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'
    permissions:
      contents: read
      packages: write
      security-events: write
      actions: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v6

    - name: Get versions
      id: versions
      run: |
        # Get latest CRI-O version with error handling
        CRIO_RESPONSE=$(curl -s https://api.github.com/repos/cri-o/cri-o/releases/latest)
        if echo "$CRIO_RESPONSE" | jq -e '.tag_name' > /dev/null 2>&1; then
          CRIO_LATEST=$(echo "$CRIO_RESPONSE" | jq -r '.tag_name')
        else
          echo "Error getting CRI-O version: $CRIO_RESPONSE"
          CRIO_LATEST="v1.33.7"  # fallback version
        fi
        
        # Get last 3 Kubernetes versions (stable releases only) with error handling
        K8S_RESPONSE=$(curl -s https://api.github.com/repos/kubernetes/kubernetes/releases)
        if echo "$K8S_RESPONSE" | jq -e '.[0].tag_name' > /dev/null 2>&1; then
          K8S_VERSIONS=$(echo "$K8S_RESPONSE" | \
            jq -r '[.[] | select(.prerelease == false and (.tag_name | test("^v[0-9]+\\.[0-9]+\\.[0-9]+$"))) | .tag_name] | .[0:3] | .[]')
        else
          echo "Error getting Kubernetes versions: $K8S_RESPONSE"
          K8S_VERSIONS=$(echo -e "v1.35.0\nv1.34.3\nv1.33.7")  # fallback versions
        fi
        
        # Convert to array for easier handling
        K8S_ARRAY=()
        while IFS= read -r version; do
          K8S_ARRAY+=("$version")
        done <<< "$K8S_VERSIONS"
        
        # Primary version is the latest
        LATEST_K8S="${K8S_ARRAY[0]}"
        
        echo "crio_latest=$CRIO_LATEST" >> $GITHUB_OUTPUT
        echo "k8s_latest=$LATEST_K8S" >> $GITHUB_OUTPUT
        echo "k8s_versions=${K8S_ARRAY[*]}" >> $GITHUB_OUTPUT
        
        echo "Latest CRI-O: $CRIO_LATEST"
        echo "Latest K8s: $LATEST_K8S"
        echo "Supported K8s versions: ${K8S_ARRAY[*]}"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}
          type=raw,value=${{ steps.versions.outputs.crio_latest }}
          type=raw,value=latest,enable={{is_default_branch}}
          type=sha

    - name: Build multi-version images
      run: |
        CRIO_LATEST="${{ steps.versions.outputs.crio_latest }}"
        K8S_VERSIONS="${{ steps.versions.outputs.k8s_versions }}"
        
        # Create array from space-separated versions
        IFS=' ' read -ra VERSIONS_ARRAY <<< "$K8S_VERSIONS"
        
        # Build images for each supported Kubernetes version
        for K8S_VERSION in "${VERSIONS_ARRAY[@]}"; do
          echo "ðŸ”¨ Building image for Kubernetes $K8S_VERSION with CRI-O $CRIO_LATEST"
          
          # Build intermediate image first
          docker build \
            --build-arg CRIO_VERSION=$CRIO_LATEST \
            --build-arg KIND_VERSION=$K8S_VERSION \
            -t kindnode/crio:$CRIO_LATEST-$K8S_VERSION-tmp \
            .
          
          # Build final image with image migration (similar to build script)
          docker run --privileged --rm -d --name crio-builder-$K8S_VERSION --entrypoint sleep kindnode/crio:$CRIO_LATEST-$K8S_VERSION-tmp infinity
          
          # Start daemons
          docker exec -d crio-builder-$K8S_VERSION containerd
          docker exec -d crio-builder-$K8S_VERSION crio
          
          # Wait for daemons to start
          sleep 10
          
          # Migrate images
          docker exec crio-builder-$K8S_VERSION bash -c 'for IMG in $(ctr -n k8s.io images list -q | grep "registry.k8s.io/kube-"); do echo "Migrating $IMG ..." && ctr -n k8s.io image export --platform "linux/amd64" - "$IMG" | podman load; done'
          
          # Commit final image
          docker commit --change 'ENTRYPOINT [ "/usr/local/bin/entrypoint", "/sbin/init" ]' crio-builder-$K8S_VERSION kindnode/crio:$CRIO_LATEST-$K8S_VERSION
          
          # Tag for registry
          docker tag kindnode/crio:$CRIO_LATEST-$K8S_VERSION ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$K8S_VERSION
          docker tag kindnode/crio:$CRIO_LATEST-$K8S_VERSION ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$CRIO_LATEST-k8s-$K8S_VERSION
          
          # Push images
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$K8S_VERSION
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$CRIO_LATEST-k8s-$K8S_VERSION
          
          # Cleanup
          docker kill crio-builder-$K8S_VERSION
          
          echo "âœ… Built and pushed: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$K8S_VERSION"
        done
        
        # Tag and push the main CRI-O version (using latest K8s)
        LATEST_K8S="${VERSIONS_ARRAY[0]}"
        docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$LATEST_K8S ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$CRIO_LATEST
        docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$LATEST_K8S ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$CRIO_LATEST
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

    - name: Run Trivy vulnerability scanner
      if: github.repository_owner == github.actor
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.versions.outputs.crio_latest }}
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results to GitHub Security tab
      if: github.repository_owner == github.actor
      uses: github/codeql-action/upload-sarif@v4
      with:
        sarif_file: 'trivy-results.sarif'