name: Auto Release on Upstream Updates

on:
  schedule:
    # Check for new versions weekly on Mondays at 6 AM UTC
    - cron: '0 6 * * 1'
  workflow_dispatch:
    inputs:
      force_release:
        description: 'Force release even if no version changes detected'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  check-upstream-versions:
    runs-on: ubuntu-latest
    outputs:
      crio_latest: ${{ steps.versions.outputs.crio_latest }}
      k8s_latest: ${{ steps.versions.outputs.k8s_latest }}
      k8s_versions: ${{ steps.versions.outputs.k8s_versions }}
      crio_current: ${{ steps.versions.outputs.crio_current }}
      k8s_current: ${{ steps.versions.outputs.k8s_current }}
      should_release: ${{ steps.compare.outputs.should_release }}
      release_tag: ${{ steps.versions.outputs.release_tag }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v6

    - name: Get current and latest versions
      id: versions
      run: |
        # Get current versions from Dockerfile
        CURRENT_CRIO=$(grep "ARG CRIO_VERSION" Dockerfile | head -1 | sed 's/.*=//' || echo "")
        CURRENT_K8S=$(grep "ARG KIND_VERSION" Dockerfile | head -1 | sed 's/.*=//' || echo "v1.31.0")
        
        # Get latest CRI-O version with error handling
        CRIO_RESPONSE=$(curl -s https://api.github.com/repos/cri-o/cri-o/releases/latest)
        if echo "$CRIO_RESPONSE" | jq -e '.tag_name' > /dev/null 2>&1; then
          LATEST_CRIO=$(echo "$CRIO_RESPONSE" | jq -r '.tag_name')
        else
          echo "Error getting CRI-O version: $CRIO_RESPONSE"
          LATEST_CRIO="v1.33.7"  # fallback version
        fi
        
        # Get last 3 Kubernetes versions (stable releases only) with error handling
        K8S_RESPONSE=$(curl -s https://api.github.com/repos/kubernetes/kubernetes/releases)
        if echo "$K8S_RESPONSE" | jq -e '.[0].tag_name' > /dev/null 2>&1; then
          K8S_VERSIONS=$(echo "$K8S_RESPONSE" | \
            jq -r '[.[] | select(.prerelease == false and (.tag_name | test("^v[0-9]+\\.[0-9]+\\.[0-9]+$"))) | .tag_name] | .[0:3] | .[]')
        else
          echo "Error getting Kubernetes versions: $K8S_RESPONSE"
          K8S_VERSIONS=$(echo -e "v1.35.0\nv1.34.3\nv1.33.7")  # fallback versions
        fi
        
        # Convert to array for easier handling
        K8S_ARRAY=()
        while IFS= read -r version; do
          K8S_ARRAY+=("$version")
        done <<< "$K8S_VERSIONS"
        
        # Primary version is the latest
        LATEST_K8S="${K8S_ARRAY[0]}"
        
        # Create release tag based on CRI-O version (primary component)
        RELEASE_TAG="${LATEST_CRIO}"
        
        echo "crio_current=$CURRENT_CRIO" >> $GITHUB_OUTPUT
        echo "k8s_current=$CURRENT_K8S" >> $GITHUB_OUTPUT
        echo "crio_latest=$LATEST_CRIO" >> $GITHUB_OUTPUT
        echo "k8s_latest=$LATEST_K8S" >> $GITHUB_OUTPUT
        echo "k8s_versions=${K8S_ARRAY[*]}" >> $GITHUB_OUTPUT
        echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT
        
        echo "Current CRI-O: $CURRENT_CRIO"
        echo "Latest CRI-O: $LATEST_CRIO"
        echo "Current K8s: $CURRENT_K8S"
        echo "Latest K8s: $LATEST_K8S"
        echo "Supported K8s versions: ${K8S_ARRAY[*]}"
        echo "Release tag: $RELEASE_TAG"

    - name: Check if release needed
      id: compare
      run: |
        CURRENT_CRIO="${{ steps.versions.outputs.crio_current }}"
        LATEST_CRIO="${{ steps.versions.outputs.crio_latest }}"
        CURRENT_K8S="${{ steps.versions.outputs.k8s_current }}"
        LATEST_K8S="${{ steps.versions.outputs.k8s_latest }}"
        FORCE_RELEASE="${{ github.event.inputs.force_release }}"
        
        SHOULD_RELEASE=false
        RELEASE_REASON=""
        
        echo "üîç Checking if release is needed..."
        echo "Current CRI-O: $CURRENT_CRIO"
        echo "Latest CRI-O: $LATEST_CRIO"
        echo "Current K8s: $CURRENT_K8S"
        echo "Latest K8s: $LATEST_K8S"
        echo "Force release: $FORCE_RELEASE"
        
        # Check if versions changed or force release requested
        if [ "$CURRENT_CRIO" != "$LATEST_CRIO" ]; then
          SHOULD_RELEASE=true
          RELEASE_REASON="CRI-O version updated: $CURRENT_CRIO ‚Üí $LATEST_CRIO"
        elif [ "$CURRENT_K8S" != "$LATEST_K8S" ]; then
          SHOULD_RELEASE=true
          RELEASE_REASON="Kubernetes version updated: $CURRENT_K8S ‚Üí $LATEST_K8S"
        elif [ "$FORCE_RELEASE" = "true" ]; then
          SHOULD_RELEASE=true
          RELEASE_REASON="Manual force release requested"
        fi
        
        # Check if this release tag already exists
        RELEASE_TAG="${{ steps.versions.outputs.release_tag }}"
        if [ "$SHOULD_RELEASE" = "true" ] && git tag -l | grep -q "^$RELEASE_TAG$"; then
          echo "‚ùå Release tag $RELEASE_TAG already exists, skipping release"
          SHOULD_RELEASE=false
          RELEASE_REASON="Release already exists"
        fi
        
        echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
        echo "release_reason=$RELEASE_REASON" >> $GITHUB_OUTPUT
        
        if [ "$SHOULD_RELEASE" = "true" ]; then
          echo "‚úÖ RELEASE NEEDED: $RELEASE_REASON"
          echo "üöÄ Will proceed with building and releasing image"
        else
          echo "‚è≠Ô∏è  NO RELEASE NEEDED: No version changes detected"
          echo "üõë Stopping pipeline - nothing to do"
        fi

  no-release-needed:
    needs: check-upstream-versions
    if: needs.check-upstream-versions.outputs.should_release == 'false'
    runs-on: ubuntu-latest
    
    steps:
    - name: No release needed
      run: |
        echo "‚è≠Ô∏è  No new releases found - pipeline stopped"
        echo ""
        echo "üìä Current Status:"
        echo "   CRI-O: ${{ needs.check-upstream-versions.outputs.crio_current }} (latest: ${{ needs.check-upstream-versions.outputs.crio_latest }})"
        echo "   KIND: ${{ needs.check-upstream-versions.outputs.k8s_current }} (latest: ${{ needs.check-upstream-versions.outputs.k8s_latest }})"
        echo "   Supported K8s versions: ${{ needs.check-upstream-versions.outputs.k8s_versions }}"
        echo ""
        echo "‚úÖ Repository is up to date!"
        echo "üîÑ Next check: Weekly on Monday at 6 AM UTC"

  auto-release:
    needs: check-upstream-versions
    if: needs.check-upstream-versions.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v6

    - name: Update versions in files
      run: |
        CRIO_LATEST="${{ needs.check-upstream-versions.outputs.crio_latest }}"
        K8S_LATEST="${{ needs.check-upstream-versions.outputs.k8s_latest }}"
        
        # Update Dockerfile
        sed -i "s/ARG KUBERNETES_VERSION=.*/ARG KUBERNETES_VERSION=$K8S_LATEST/" Dockerfile
        sed -i "s/ARG CRIO_VERSION.*/ARG CRIO_VERSION=$CRIO_LATEST/" Dockerfile
        
        # Update README version references
        sed -i "s/crio-in-kind:v[0-9]\+\.[0-9]\+/crio-in-kind:$CRIO_LATEST/g" README.md
        sed -i "s/kindest\/node:v[0-9]\+\.[0-9]\+\.[0-9]\+/kindest\/node:$K8S_LATEST/" README.md

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=raw,value=${{ needs.check-upstream-versions.outputs.crio_latest }}
          type=raw,value=latest

    - name: Build multi-version images
      run: |
        CRIO_LATEST="${{ needs.check-upstream-versions.outputs.crio_latest }}"
        K8S_VERSIONS="${{ needs.check-upstream-versions.outputs.k8s_versions }}"
        
        # Create array from space-separated versions
        IFS=' ' read -ra VERSIONS_ARRAY <<< "$K8S_VERSIONS"
        
        # Build images for each supported Kubernetes version
        for K8S_VERSION in "${VERSIONS_ARRAY[@]}"; do
          echo "üî® Building image for Kubernetes $K8S_VERSION with CRI-O $CRIO_LATEST"
          
          # Build and push image
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --build-arg CRIO_VERSION=$CRIO_LATEST \
            --build-arg KUBERNETES_VERSION=$K8S_VERSION \
            --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$K8S_VERSION \
            --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$CRIO_LATEST-k8s-$K8S_VERSION \
            --push \
            .
            
          echo "‚úÖ Built and pushed: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$K8S_VERSION"
        done
        
        # Tag and push the latest CRI-O version (using latest K8s)
        LATEST_K8S="${VERSIONS_ARRAY[0]}"
        
        docker buildx build \
          --platform linux/amd64,linux/arm64 \
          --build-arg CRIO_VERSION=$CRIO_LATEST \
          --build-arg KUBERNETES_VERSION=$LATEST_K8S \
          --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$CRIO_LATEST \
          --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
          --push \
          .

    - name: Generate image list with digests
      id: image_list
      run: |
        CRIO_LATEST="${{ needs.check-upstream-versions.outputs.crio_latest }}"
        K8S_VERSIONS="${{ needs.check-upstream-versions.outputs.k8s_versions }}"
        
        # Create array from space-separated versions
        IFS=' ' read -ra VERSIONS_ARRAY <<< "$K8S_VERSIONS"
        
        echo "## üê≥ Images pre-built for this release:" > image-list.md
        echo "" >> image-list.md
        
        # Get digests for each version
        for K8S_VERSION in "${VERSIONS_ARRAY[@]}"; do
          # Pull image to get digest
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$K8S_VERSION
          
          # Get the digest
          DIGEST=$(docker inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$K8S_VERSION --format='{{index .RepoDigests 0}}' | cut -d'@' -f2)
          
          echo "**$K8S_VERSION**: \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$K8S_VERSION@$DIGEST\`" >> image-list.md
          echo "" >> image-list.md
        done
        
        # Store the content for use in release notes
        echo "IMAGE_LIST<<EOF" >> $GITHUB_OUTPUT
        cat image-list.md >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Test the built images
      run: |
        CRIO_LATEST="${{ needs.check-upstream-versions.outputs.crio_latest }}"
        K8S_VERSIONS="${{ needs.check-upstream-versions.outputs.k8s_versions }}"
        
        # Create array from space-separated versions
        IFS=' ' read -ra VERSIONS_ARRAY <<< "$K8S_VERSIONS"
        
        # Test each built image
        for K8S_VERSION in "${VERSIONS_ARRAY[@]}"; do
          echo "üß™ Testing image for Kubernetes $K8S_VERSION"
          
          # Pull and test the image
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$K8S_VERSION
          
          # Basic smoke test
          docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$K8S_VERSION crio version
          
          echo "‚úÖ Image $K8S_VERSION passed smoke test"
        done

    - name: Commit version updates
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add Dockerfile README.md
        git commit -m "chore: update to CRI-O ${{ needs.check-upstream-versions.outputs.crio_latest }} and Kubernetes ${{ needs.check-upstream-versions.outputs.k8s_latest }}" || exit 0
        git push

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ needs.check-upstream-versions.outputs.release_tag }}
        name: "CRI-O ${{ needs.check-upstream-versions.outputs.crio_latest }}"
        body: |
          ## üöÄ Automated Release
          
          This release includes CRI-O ${{ needs.check-upstream-versions.outputs.crio_latest }} with support for the last 3 stable Kubernetes versions.
          
          ### üì¶ What's Included
          - **CRI-O**: `${{ needs.check-upstream-versions.outputs.crio_latest }}`
          - **Supported Kubernetes versions**: `${{ needs.check-upstream-versions.outputs.k8s_versions }}`
          
          ${{ steps.image_list.outputs.IMAGE_LIST }}
          
          ### üöÄ Quick Start
          ```bash
          # Use with latest Kubernetes version
          kind create cluster --image ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.check-upstream-versions.outputs.k8s_latest }}
          
          # Or specify a specific Kubernetes version
          kind create cluster --image ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v1.34.3
          ```
          
          ### üè∑Ô∏è Available Tags
          - `${{ needs.check-upstream-versions.outputs.crio_latest }}` - CRI-O version tag (latest K8s)
          - `latest` - Always points to latest CRI-O with latest K8s
          - `v1.x.x` - Specific Kubernetes versions with latest CRI-O
          - `${{ needs.check-upstream-versions.outputs.crio_latest }}-k8s-v1.x.x` - Full version tags
          
          ### üß™ Testing Kubernetes Features
          Test Kubernetes features that behave differently with CRI-O:
          ```bash
          kubectl apply -f examples/test-image-name-blocking.yaml
          ```
          
          ### üìã Changes from Previous Release
          - Updated CRI-O from `${{ needs.check-upstream-versions.outputs.crio_current }}` to `${{ needs.check-upstream-versions.outputs.crio_latest }}`
          - Supporting last 3 stable Kubernetes versions: `${{ needs.check-upstream-versions.outputs.k8s_versions }}`
          
          ---
          
          *This release was automatically created when new upstream CRI-O versions were detected.*
        draft: false
        prerelease: false
        generate_release_notes: true

  notify-success:
    needs: [check-upstream-versions, auto-release]
    if: needs.check-upstream-versions.outputs.should_release == 'true' && success()
    runs-on: ubuntu-latest
    
    steps:
    - name: Notify success
      run: |
        echo "‚úÖ Successfully released CRI-O KIND images:"
        echo "   CRI-O Version: ${{ needs.check-upstream-versions.outputs.crio_latest }}"
        echo "   Supported K8s versions: ${{ needs.check-upstream-versions.outputs.k8s_versions }}"
        echo "   Registry: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"